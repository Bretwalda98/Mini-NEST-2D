<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mini Nest 2D — Jobs + Materials + CNC (v0.9)</title>
<style>
  :root{
    --bg:#0b0e14; --panel:#121625; --panel2:#0e1322; --ink:#e8ecf1; --muted:#9aa4b2; --accent:#4da3ff; --accent2:#47e5a1;
    --grid:#1a2035; --grid2:#232b45; --warn:#f5b145; --danger:#ff6b6b; --ok:#46d19a; --sel:#7aa2ff44; --hud:#0e1628cc; --hud-border:#2a3a70; --bar:#0f1426; --bar2:#0b1021; --stroke:#1e2335;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  button,input,select,textarea{font:inherit}

  .app{display:grid; grid-template-rows:56px 1fr 28px; height:100%}

  header{display:flex; align-items:center; gap:10px; padding:0 10px; background:linear-gradient(180deg,var(--bar),var(--bar2)); border-bottom:1px solid #1b2140}
  header .title{font-weight:700; letter-spacing:.3px; display:flex; align-items:center; gap:.6rem}
  header .title .dot{width:10px;height:10px;border-radius:50%;background:var(--accent)}
  header .spacer{flex:1}
  header .btn{background:#0d1530;border:1px solid #1f2a55;color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer}
  header .btn:hover{background:#121c3f}
  header .group{display:flex; gap:8px}

  main{display:grid; grid-template-columns:360px 1fr 360px; gap:0; min-height:0}
  aside{background:var(--panel); border-right:1px solid #1b2140; display:flex; flex-direction:column; min-width:0}
  aside.right{border-right:none; border-left:1px solid #1b2140}
  .section{padding:10px; border-bottom:1px solid #1b2140}
  .section h3{margin:0 0 6px; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em}
  .section .row{display:flex; gap:8px; margin:6px 0; align-items:center}
  .section .row > label{min-width:110px; color:var(--muted); font-size:12px}
  .section input[type="number"], .section input[type="text"], .section select{width:100%; padding:6px 8px; border-radius:8px; border:1px solid #2a355f; background:#0d1327; color:var(--ink)}
  .mini{font-size:12px; color:var(--muted)}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid #2a355f; background:#0c142f; font-size:12px}

  .parts{flex:1; overflow:auto}
  table{width:100%; border-collapse:collapse; font-size:13px}
  th,td{padding:6px 8px; border-bottom:1px solid #202a50; text-align:left}
  th{position:sticky; top:0; background:#101735; z-index:1}
  tr:hover{background:#0f1733}

  .viewport{position:relative; background:radial-gradient(800px 400px at 70% -10%, rgba(56,189,248,.12), transparent 60%), radial-gradient(600px 300px at -10% -10%, rgba(168,85,247,.10), transparent 60%)}
  canvas{width:100%; height:100%; display:block; background:
    linear-gradient(0deg, transparent 24%, var(--grid) 25%, var(--grid) 26%, transparent 27%, transparent 74%, var(--grid) 75%, var(--grid) 76%, transparent 77%),
    linear-gradient(90deg, transparent 24%, var(--grid) 25%, var(--grid) 26%, transparent 27%, transparent 74%, var(--grid) 75%, var(--grid) 76%, transparent 77%);
    background-size:48px 48px; border-left:1px solid #1b2140; border-right:1px solid #1b2140}
  .overlay{position:absolute; inset:0; pointer-events:none}
  .hud{position:absolute; left:10px; bottom:10px; background:var(--hud); border:1px solid var(--hud-border); border-radius:12px; padding:8px 10px; font-size:12px}

  footer{display:flex; align-items:center; gap:12px; padding:0 10px; background:linear-gradient(180deg,var(--bar2),var(--bar)); border-top:1px solid #1b2140; font-size:12px; color:var(--muted)}
  footer .kbd{padding:1px 6px; border:1px solid #2a355f; border-bottom-width:2px; border-radius:6px; background:#0d1327; color:#cfe1ff}
  footer .right{margin-left:auto}

  .btn-sm{background:#0d1530;border:1px solid #1f2a55;color:var(--ink);padding:4px 8px;border-radius:8px;cursor:pointer}
  .btn-sm:hover{background:#121c3f}
  .danger{color:#ff8d8d}
  .ok{color:#71f1bd}
  .warn{color:#f8d486}
  .muted{color:var(--muted)}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .kbdchip{padding:2px 6px; border:1px solid #2a355f; border-radius:6px; background:#0d1327; font-size:11px}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title"><span class="dot"></span>Mini Nest 2D <span class="pill">Jobs + CNC</span> <span class="pill" title="Single-file prototype">v0.9</span></div>
    <div class="group">
      <button class="btn" id="btnJobNew">New Job</button>
      <button class="btn" id="btnJobLoad">Load Job</button>
      <button class="btn" id="btnJobSave">Save Job</button>
    </div>
    <div class="group">
      <button class="btn" id="btnNest">Run Nest</button>
      <button class="btn" id="btnExportSVG">Export SVG</button>
      <button class="btn" id="btnExportCSV">Export CSV</button>
      <button class="btn" id="btnExportGCode">Export All G-code</button>
    </div>
    <span class="spacer"></span>
    <div class="group">
      <button class="btn" id="btnProfiles">CNC Profiles</button>
      <button class="btn" id="btnMaterials">Materials</button>
      <button class="btn" id="btnHelp">Help</button>
    </div>
  </header>

  <main>
    <!-- LEFT: Job + Parts -->
    <aside>
      <div class="section">
        <h3>Job</h3>
        <div class="row"><label>Job Name</label><input type="text" id="jobName" value="DemoJob" /></div>
        <div class="row"><label>Material</label>
          <select id="jobMaterial"></select>
        </div>
        <div class="row"><label>Sheet Size</label>
          <div class="grid2" style="flex:1">
            <input type="number" id="sheetW" value="3000" min="1"/>
            <input type="number" id="sheetH" value="1500" min="1"/>
          </div>
        </div>
        <div class="row"><label>Margin</label><input type="number" id="sheetMargin" value="10" min="0"/></div>
        <div class="row"><label>Kerf</label><input type="number" id="kerf" value="2" min="0" step="0.1"/></div>
        <div class="row"><label>Grain</label>
          <select id="grainLock">
            <option value="none">None (free rotate)</option>
            <option value="0">Lock 0°</option>
            <option value="90">Lock 90°</option>
          </select>
        </div>
      </div>

      <div class="section">
        <h3>Parts</h3>
        <div class="row">
          <button class="btn-sm" id="btnAddRect">+ Rectangle</button>
          <button class="btn-sm" id="btnAddCircle">+ Circle</button>
        </div>
        <div class="row">
          <label class="btn-sm" style="cursor:pointer">Import CSV
            <input id="csvInput" type="file" accept=".csv" style="display:none" />
          </label>
          <label class="btn-sm" style="cursor:pointer">Import Folder
            <input id="folderInput" type="file" webkitdirectory directory multiple style="display:none" />
          </label>
        </div>
        <div class="mini">CSV: name,width,height,qty,rot</div>
      </div>

      <div class="parts">
        <table id="partsTable">
          <thead>
            <tr><th style="width:34px">#</th><th>Name</th><th>W</th><th>H</th><th>Qty</th><th>Rot</th><th></th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="section">
        <div class="row">
          <button class="btn-sm" id="btnClearParts">Clear Parts</button>
        </div>
      </div>
    </aside>

    <!-- CENTER: Viewport -->
    <div class="viewport">
      <canvas id="view"></canvas>
      <div class="overlay">
        <div class="hud" id="hud"></div>
      </div>
    </div>

    <!-- RIGHT: Nest + Toolpath -->
    <aside class="right">
      <div class="section">
        <h3>NESTING</h3>
        <div class="row"><label>Method</label>
          <select id="strategy">
            <option value="shelf">Rectangular: Shelf (fast)</option>
            <option value="bl">Rectangular: Bottom-Left</option>
            <option value="true">True-Shape (beta)</option>
          </select>
        </div>
        <div class="row"><label>Sort</label>
          <select id="sortBy">
            <option value="area">Area ↓</option>
            <option value="h">Height ↓</option>
            <option value="w">Width ↓</option>
          </select>
        </div>
        <div class="row"><label>Rotation</label>
          <select id="rotation">
            <option value="90">0° / 90°</option>
            <option value="0">Fixed (per-part)</option>
          </select>
        </div>
        <div class="row"><button class="btn-sm" id="btnClearPlacements">Clear Layout</button></div>
        <div class="mini warn">True-Shape beta approximates NFP using coarse polygon sampling; arcs ignored in DXF.</div>
      </div>

      <div class="section">
        <h3>TOOLPATH & CNC</h3>
        <div class="row"><label>Profile</label>
          <select id="cncProfile"></select>
        </div>
        <div class="row"><label>Lead-in</label>
          <div class="grid2" style="flex:1">
            <input type="number" id="leadLen" value="5" min="0" step="0.1" />
            <select id="leadType">
              <option value="line">Line</option>
              <option value="arc">Arc</option>
            </select>
          </div>
        </div>
        <div class="row"><label>Pierce dwell (s)</label><input type="number" id="pierceDwell" value="0.2" min="0" step="0.1"/></div>
        <div class="row"><label>Compensation</label>
          <select id="compSide">
            <option value="in">Inside (holes)</option>
            <option value="out" selected>Outside (external)</option>
          </select>
        </div>
        <div class="row"><button class="btn-sm" id="btnPreviewToolpath">Preview Toolpaths</button></div>
      </div>

      <div class="section">
        <h3>PROJECT</h3>
        <div class="row"><label class="btn-sm" style="cursor:pointer">Import DXF (beta)
          <input id="dxfInput" type="file" accept=".dxf" style="display:none" />
        </label>
        <button class="btn-sm" id="btnAddDXFAsPart">Add DXF → Part</button></div>
        <div class="mini warn">DXF beta: LWPOLYLINE (straight) only; arcs ignored for now.</div>
      </div>
    </aside>
  </main>

  <footer>
    <div>Zoom: <span id="zoomLbl">100%</span></div>
    <div>Sheets: <span id="sheetsLbl">1</span></div>
    <div class="right">Pan: <span class="kbd">Space</span> + drag • Zoom: wheel • Reset: <span class="kbd">R</span></div>
  </footer>
</div>

<script>
/* ==============================
   Utilities
============================== */
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
function download(filename, text){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([text],{type:'application/octet-stream'}));
  a.download=filename; a.click(); URL.revokeObjectURL(a.href);
}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function uid(){return Math.random().toString(36).slice(2,9)}
function toast(msg){
  const el=document.createElement('div');
  el.textContent=msg;
  el.style.cssText='position:fixed;right:12px;bottom:40px;background:#0e1628cc;border:1px solid #2a3a70;color:#e8ecf1;padding:10px 12px;border-radius:10px;font-size:12px;z-index:9999;';
  document.body.appendChild(el); setTimeout(()=>el.remove(), 2600);
}

/* ==============================
   Data Models
============================== */
class Part{
  constructor({name,w,h,qty=1,rot=true,shape='rect',points=null}){
    this.id=uid(); this.name=name||('P_'+this.id);
    this.w=+w; this.h=+h; this.qty=+qty|0; this.rot=!!rot;
    this.shape=shape; this.points=points; // [[x,y],...]
  }
  area(){ return this.w*this.h; }
}
class Placement{ constructor({partId,x,y,w,h,rot=false,sheet=0}){Object.assign(this,{partId,x,y,w,h,rot,sheet});} }
class Material{ constructor({name,thickness=6, notes=''}){ this.id=uid(); this.name=name; this.thickness=+thickness; this.notes=notes; }}
class CNCProfile{ constructor({name='GRBL_Default', unit='mm', feed=1200, pierceDwell=0.2, safeZ=5, cutZ=0, rapid=3000, spindle=0, post='grbl'}){Object.assign(this,{id:uid(),name,unit,feed,pierceDwell,safeZ,cutZ,rapid,spindle,post});}}
class Job{ constructor(){ this.name='DemoJob'; this.materialId=null; this.sheet={w:3000,h:1500,margin:10,kerf:2,grain:'none'}; this.parts=[]; this.placements=[]; this.sheets=1; }}

/* ==============================
   State
============================== */
const state={
  job:new Job(),
  camera:{x:0,y:0,zoom:1},
  dragging:false, last:{x:0,y:0},
  materials:[
    new Material({name:'S235'}),
    new Material({name:'S355'}),
    new Material({name:'COR-TEN (Corten)'}),
    new Material({name:'Aluminium 3mm'}),
    new Material({name:'Stainless 2mm'})
  ],
  profiles:[ new CNCProfile({name:'GRBL_Default'}), new CNCProfile({name:'Plasma_Generic', feed:1800, pierceDwell:0.4}) ],
  dxfGeom:null,
};

/* ==============================
   UI: Materials & Profiles
============================== */
function refreshMaterialSelect(){
  const sel=$('#jobMaterial');
  if(!sel) return;
  sel.innerHTML='';
  for(const m of state.materials){
    const opt=document.createElement('option'); opt.value=m.id; opt.textContent=m.name; sel.appendChild(opt);
  }
  if(!state.job.materialId) state.job.materialId=state.materials[0]?.id||null;
  sel.value=state.job.materialId||'';
}
function refreshProfileSelect(){
  const sel=$('#cncProfile'); if(!sel) return;
  sel.innerHTML='';
  for(const p of state.profiles){
    const opt=document.createElement('option'); opt.value=p.id; opt.textContent=p.name; sel.appendChild(opt);
  }
  sel.value=state.profiles[0]?.id||'';
}
$('#btnMaterials').addEventListener('click',()=>{
  const name=prompt('Add material (name), or leave blank to cancel:\nExample: S275 10mm');
  if(!name) return; state.materials.push(new Material({name})); refreshMaterialSelect(); toast('Material added.');
});
$('#btnProfiles').addEventListener('click',()=>{
  const name=prompt('New CNC profile name (leave blank to cancel)'); if(!name) return;
  const feed=parseFloat(prompt('Feed (mm/min)', '1200'))||1200;
  const pierce=parseFloat(prompt('Pierce dwell (s)','0.2'))||0;
  const rapid=parseFloat(prompt('Rapid (mm/min)','3000'))||3000;
  state.profiles.push(new CNCProfile({name,feed,pierceDwell:pierce,rapid}));
  refreshProfileSelect(); toast('Profile added.');
});

/* ==============================
   Parts Table
============================== */
function renderParts(){
  const tbody=$('#partsTable tbody'); if(!tbody) return;
  tbody.innerHTML='';
  state.job.parts.forEach((p,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${i+1}</td>
      <td contenteditable data-key="name">${p.name}</td>
      <td contenteditable data-key="w">${p.w}</td>
      <td contenteditable data-key="h">${p.h}</td>
      <td contenteditable data-key="qty">${p.qty}</td>
      <td><input type="checkbox" data-key="rot" ${p.rot?'checked':''}></td>
      <td><button class="btn-sm danger" data-action="del">Del</button></td>`;
    tr.addEventListener('input',(e)=>{
      const key=e.target.dataset.key; if(!key) return;
      let val=e.target.textContent.trim();
      if(key==='name') p[key]=val; else p[key]=+val||0;
    });
    tr.addEventListener('change',(e)=>{ if(e.target.dataset.key==='rot') p.rot=e.target.checked; });
    tr.querySelector('[data-action="del"]').addEventListener('click',()=>{ state.job.parts.splice(i,1); renderParts(); draw(); });
    tbody.appendChild(tr);
  });
}
$('#btnAddRect').addEventListener('click',()=>{ state.job.parts.push(new Part({name:'Rect '+(state.job.parts.length+1), w:100, h:80, qty:1, rot:true})); renderParts(); });
$('#btnAddCircle').addEventListener('click',()=>{ state.job.parts.push(new Part({name:'Circle '+(state.job.parts.length+1), w:100, h:100, qty:1, rot:true, shape:'circle'})); renderParts(); });
$('#btnClearParts').addEventListener('click',()=>{ if(confirm('Remove all parts?')){ state.job.parts.length=0; renderParts(); draw(); }});

$('#csvInput').addEventListener('change', async (e)=>{
  const file=e.target.files[0]; if(!file) return; const txt=await file.text();
  const rows=txt.split(/\r?\n/).map(r=>r.trim()).filter(Boolean);
  for(const r of rows){
    const [name,w,h,qty,rot] = r.split(',');
    if(!name) continue;
    state.job.parts.push(new Part({name,w:+w,h:+h,qty:+qty||1,rot:rot!=="0"}));
  }
  renderParts(); e.target.value='';
});
$('#folderInput').addEventListener('change', async (e)=>{
  const files=[...e.target.files]; if(!files.length) return; let added=0;
  for(const f of files){
    const ext=f.name.toLowerCase().split('.').pop();
    if(ext==='csv'){
      const txt=await f.text();
      const rows=txt.split(/\r?\n/).map(r=>r.trim()).filter(Boolean);
      for(const r of rows){
        const [name,w,h,qty,rot] = r.split(',');
        if(!name) continue;
        state.job.parts.push(new Part({name,w:+w,h:+h,qty:+qty||1,rot:rot!=="0"})); added++;
      }
    } else if(ext==='dxf'){
      const txt=await f.text(); const polys=parseDXF_LWPolyline(txt);
      if(polys.length){
        const bb=boundOfPolylines(polys); const w=bb.maxX-bb.minX, h=bb.maxY-bb.minY;
        state.job.parts.push(new Part({name:f.name.replace(/\.dxf$/i,''), w, h, qty:1, rot:true, shape:'poly', points:polys[0]})); added++;
      }
    }
  }
  renderParts(); toast(`Imported ${added} part(s) from folder.`); e.target.value='';
});

/* ==============================
   Job Bindings & Persistence
============================== */
function bindJobFields(){
  ['sheetW','sheetH','sheetMargin','kerf'].forEach(id=>{
    $('#'+id).addEventListener('input',()=>{
      state.job.sheet.w=+$('#sheetW').value||0;
      state.job.sheet.h=+$('#sheetH').value||0;
      state.job.sheet.margin=+$('#sheetMargin').value||0;
      state.job.sheet.kerf=+$('#kerf').value||0;
      resetView(); draw();
    });
  });
  $('#grainLock').addEventListener('change',()=>{ state.job.sheet.grain=$('#grainLock').value; });
  $('#jobName').addEventListener('input',(e)=>{ state.job.name=e.target.value; });
}
function saveJob(){
  const data=JSON.stringify({job:state.job, materials:state.materials, profiles:state.profiles}, null, 2);
  download(`${state.job.name||'Job'}.mininest.json`, data);
}
function loadJobFromText(txt){
  try{
    const obj=JSON.parse(txt);
    state.materials=obj.materials||state.materials;
    state.profiles=obj.profiles||state.profiles;
    state.job=new Job(); Object.assign(state.job, obj.job||{});
    refreshMaterialSelect(); refreshProfileSelect(); renderParts(); resetView(); draw();
  }catch(e){ alert('Invalid job JSON'); }
}
$('#btnJobSave').addEventListener('click', saveJob);
$('#btnJobLoad').addEventListener('click', ()=>{
  const inp=document.createElement('input'); inp.type='file'; inp.accept='.json';
  inp.onchange=async ()=>{ const f=inp.files[0]; if(!f) return; const txt=await f.text(); loadJobFromText(txt); };
  inp.click();
});
$('#btnJobNew').addEventListener('click', ()=>{
  if(!confirm('Start a new job?')) return;
  state.job=new Job(); state.job.name='NewJob'; state.job.materialId=state.materials[0]?.id||null;
  renderParts(); refreshMaterialSelect(); resetView(); draw();
});

/* ==============================
   Viewport Render
============================== */
const canvas=$('#view'); const ctx=canvas.getContext('2d');
function resizeCanvas(){
  const dpr=window.devicePixelRatio||1; const r=canvas.getBoundingClientRect();
  canvas.width=Math.max(1,Math.floor(r.width*dpr)); canvas.height=Math.max(1,Math.floor(r.height*dpr));
  ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); draw();
}
window.addEventListener('resize',resizeCanvas);

function worldToScreen(x,y){
  const zx=state.camera.zoom, zy=zx; const ox=state.camera.x, oy=state.camera.y;
  const r=canvas.getBoundingClientRect(); const cx=r.width/2, cy=r.height/2;
  return {x: cx + (x-ox)*zx, y: cy + (y-oy)*zy};
}
function screenToWorld(x,y){
  const zx=state.camera.zoom; const r=canvas.getBoundingClientRect();
  const cx=r.width/2, cy=r.height/2; const ox=state.camera.x, oy=state.camera.y;
  return {x: ox + (x-cx)/zx, y: oy + (y-cy)/zx};
}

function draw(){
  const r=canvas.getBoundingClientRect(); const w=r.width, h=r.height;
  ctx.clearRect(0,0,w,h);
  const S=state.job.sheet; const sheetGap=80; const count=state.job.sheets;
  $('#sheetsLbl').textContent=String(count);
  for(let s=0;s<count;s++){
    const sheetOriginX = s*(S.w + sheetGap);
    drawSheet(sheetOriginX, 0, S.w, S.h, s);
  }
  const placed=state.job.placements.length; const totalParts=state.job.parts.reduce((a,p)=>a+p.qty,0);
  $('#hud').innerHTML=`<div><b>${placed}</b> placements / <b>${totalParts}</b> parts</div><div class="muted">Kerf: ${S.kerf} • Margin: ${S.margin} • Strategy: ${$('#strategy').value}</div>`;
}
function drawSheet(wx, wy, sw, sh, sheetIndex){
  const sTL=worldToScreen(wx, wy); const sBR=worldToScreen(wx+sw, wy+sh);
  const x=sTL.x, y=sTL.y, W=sBR.x-sTL.x, H=sBR.y-sTL.y;
  ctx.save();
  ctx.fillStyle='#0a1125'; ctx.strokeStyle='#243064'; ctx.lineWidth=2;
  ctx.fillRect(x,y,W,H); ctx.strokeRect(x,y,W,H);
  // rulers
  ctx.fillStyle='#121b3a'; ctx.fillRect(x,y-18,W,18); ctx.fillRect(x-38,y,38,H);
  ctx.fillStyle='#6ba2ff'; ctx.font='11px system-ui'; ctx.textBaseline='middle';
  for(let ix=0; ix<=sw; ix+=250){ const p=worldToScreen(wx+ix, wy); ctx.fillText(String(ix), p.x-6, y-9); }
  for(let iy=0; iy<=sh; iy+=250){ const p=worldToScreen(wx, wy+iy); ctx.save(); ctx.translate(x-8, p.y); ctx.rotate(-Math.PI/2); ctx.fillText(String(iy), 0, 0); ctx.restore(); }
  // parts
  const margin=state.job.sheet.margin;
  for(const pl of state.job.placements.filter(p=>p.sheet===sheetIndex)){
    const part=state.job.parts.find(pp=>pp.id===pl.partId); if(!part) continue;
    const px=wx + margin + pl.x; const py=wy + margin + pl.y; const pw=pl.w; const ph=pl.h;
    const A=worldToScreen(px, py), B=worldToScreen(px+pw, py+ph); const sx=A.x, sy=A.y, sW=B.x-A.x, sH=B.y-A.y;
    ctx.fillStyle='#14214a'; ctx.strokeStyle='#6ba2ff'; ctx.lineWidth=1.5; ctx.fillRect(sx,sy,sW,sH); ctx.strokeRect(sx,sy,sW,sH);
    ctx.fillStyle='#bcd7ff'; ctx.font='12px system-ui'; ctx.textBaseline='top'; ctx.fillText(part.name, sx+6, sy+4);
  }
  ctx.strokeStyle='#33407a'; ctx.strokeRect(x,y,W,H);
  ctx.restore();
}

// camera
function resetView(){
  state.camera={x: state.job.sheet.w/2, y: state.job.sheet.h/2, zoom: Math.min(canvas.clientWidth/(state.job.sheet.w*1.4), canvas.clientHeight/(state.job.sheet.h*1.4))};
  updateZoomLbl(); draw();
}
function updateZoomLbl(){ $('#zoomLbl').textContent=Math.round(state.camera.zoom*100)+'%'; }
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const before=screenToWorld(e.clientX, e.clientY);
  const k=Math.exp((e.deltaY>0?-1:1)*0.1);
  state.camera.zoom=clamp(state.camera.zoom*k, 0.05, 8);
  const after=screenToWorld(e.clientX, e.clientY);
  state.camera.x += before.x-after.x; state.camera.y += before.y-after.y; updateZoomLbl(); draw();
},{passive:false});
let panMode=false;
window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){panMode=true; document.body.style.cursor='grab';} if(e.key.toLowerCase()==='r'){resetView();} });
window.addEventListener('keyup', (e)=>{ if(e.code==='Space'){panMode=false; document.body.style.cursor='default';} });
canvas.addEventListener('pointerdown', (e)=>{ if(!panMode) return; state.dragging=true; state.last.x=e.clientX; state.last.y=e.clientY; document.body.style.cursor='grabbing'; });
window.addEventListener('pointermove', (e)=>{ if(!state.dragging) return; const dx=(e.clientX-state.last.x)/state.camera.zoom; const dy=(e.clientY-state.last.y)/state.camera.zoom; state.camera.x-=dx; state.camera.y-=dy; state.last.x=e.clientX; state.last.y=e.clientY; draw(); });
window.addEventListener('pointerup', ()=>{ state.dragging=false; document.body.style.cursor=panMode?'grab':'default'; });

/* ==============================
   Nesting
============================== */
function makeInstances(parts){ const list=[]; for(const p of parts){ for(let i=0;i<p.qty;i++){ list.push({part:p, w:p.w, h:p.h}); }} return list; }
function sortInstances(instances, sortBy){ const keyFn={area:i=>-(i.w*i.h), h:i=>-i.h, w:i=>-i.w}[sortBy]||((i)=>-(i.w*i.h)); instances.sort((a,b)=> keyFn(a)-keyFn(b)); }

function nestShelf(instances, sheet, kerf){
  const placements=[]; let sheetIndex=0; let x=0,y=0,rowH=0; const W=sheet.w-2*sheet.margin, H=sheet.h-2*sheet.margin; const k=kerf;
  for(const inst of instances){
    let w=inst.w+k, h=inst.h+k;
    const allowRot = ($('#rotation').value==='90') && inst.part.rot && (sheet.grain==='none');
    if(allowRot && w>h && (x+w>W) && (x+h<=W)) { [w,h]=[h,w]; inst.rot=true; } else inst.rot=false;
    if(x+w>W){ x=0; y+=rowH; rowH=0; }
    if(y+h>H){ sheetIndex++; x=0; y=0; rowH=0; if(h>H||w>W) { console.warn('Part larger than sheet. Skipped:', inst.part.name); continue; } }
    placements.push(new Placement({partId:inst.part.id, x, y, w:inst.rot?h-k:w-k, h:inst.rot?w-k:h-k, rot:!!inst.rot, sheet:sheetIndex}));
    x+=w; rowH=Math.max(rowH,h);
  }
  return {placements, sheets: (placements.at(-1)?.sheet ?? 0)+1 };
}
function nestBottomLeft(instances, sheet, kerf){
  const placements=[]; const W=sheet.w-2*sheet.margin, H=sheet.h-2*sheet.margin; const k=kerf; let sheetIndex=0;
  function placeOnSheet(list){
    const cell=10; const cols=Math.floor(W/cell), rows=Math.floor(H/cell);
    const occ=new Array(rows).fill(0).map(()=>new Array(cols).fill(false));
    function canPlace(cx,cy,cw,ch){ if(cx+cw>cols||cy+ch>rows) return false; for(let y=cy;y<cy+ch;y++) for(let x=cx;x<cx+cw;x++) if(occ[y][x]) return false; return true; }
    function occupy(cx,cy,cw,ch){ for(let y=cy;y<cy+ch;y++) for(let x=cx;x<cx+cw;x++) occ[y][x]=true; }
    for(const inst of list){
      let placed=false;
      const allowRot = ($('#rotation').value==='90') && inst.part.rot && (sheet.grain==='none');
      for(let rotTry=0; rotTry<(allowRot?2:1); rotTry++){
        const w=(rotTry?inst.h:inst.w)+k, h=(rotTry?inst.w:inst.h)+k; const cw=Math.ceil(w/cell), ch=Math.ceil(h/cell);
        outer: for(let y=0;y<=rows-ch;y++){
          for(let x=0;x<=cols-cw;x++){
            if(canPlace(x,y,cw,ch)){
              occupy(x,y,cw,ch); const px=x*cell, py=y*cell;
              placements.push(new Placement({partId:inst.part.id, x:px, y:py, w:(rotTry?inst.h:inst.w), h:(rotTry?inst.w:inst.h), rot:!!rotTry, sheet:sheetIndex}));
              placed=true; break outer;
            }
          }
        }
        if(placed) break;
      }
      if(!placed){
        sheetIndex++;
        const rest=list.slice(list.indexOf(inst));
        const res=placeOnSheet(rest); sheetIndex+=res?.sheets?res.sheets-1:0; return;
      }
    }
    return;
  }
  placeOnSheet(instances);
  return {placements, sheets:(placements.at(-1)?.sheet ?? 0)+1};
}
// True-shape (beta) — coarse mask packing
function nestTrueShape(instances, sheet){
  const placements=[]; const W=sheet.w-2*sheet.margin, H=sheet.h-2*sheet.margin; const cell=5; const cols=Math.floor(W/cell), rows=Math.floor(H/cell); let sheetIndex=0;
  function place(list){
    let occ=new Array(rows).fill(0).map(()=>new Array(cols).fill(false));
    function can(px,py,mask){ if(px+mask.w>cols||py+mask.h>rows) return false; for(let y=0;y<mask.h;y++) for(let x=0;x<mask.w;x++){ if(mask.data[y][x] && occ[py+y][px+x]) return false; } return true; }
    function put(px,py,mask){ for(let y=0;y<mask.h;y++) for(let x=0;x<mask.w;x++){ if(mask.data[y][x]) occ[py+y][px+x]=true; } }
    for(const inst of list){
      const mask=makeMask(inst.part, cell); let placed=false;
      for(let y=0;y<=rows-mask.h;y++){
        for(let x=0;x<=cols-mask.w;x++){
          if(can(x,y,mask)){
            put(x,y,mask);
            placements.push(new Placement({partId:inst.part.id, x:x*cell, y:y*cell, w:inst.part.w, h:inst.part.h, rot:false, sheet:sheetIndex}));
            placed=true; break;
          }
        }
        if(placed) break;
      }
      if(!placed){
        sheetIndex++; // new sheet, reset occupancy
        occ=new Array(rows).fill(0).map(()=>new Array(cols).fill(false));
        const idx=list.indexOf(inst);
        const rest=list.slice(idx);
        for(const it of rest){
          const m=makeMask(it.part, cell); let done=false;
          for(let y=0;y<=rows-m.h;y++){
            for(let x=0;x<=cols-m.w;x++){
              if(can(x,y,m)){ put(x,y,m); placements.push(new Placement({partId:it.part.id, x:x*cell, y:y*cell, w:it.part.w, h:it.part.h, rot:false, sheet:sheetIndex})); done=true; break; }
            }
            if(done) break;
          }
        }
        return;
      }
    }
  }
  place(instances);
  return {placements, sheets:(placements.at(-1)?.sheet ?? 0)+1};
}
function makeMask(part, cell){
  const w=Math.ceil(part.w/cell), h=Math.ceil(part.h/cell);
  const data=new Array(h).fill(0).map(()=>new Array(w).fill(false));
  if(part.shape==='circle'){
    const rx=w/2, ry=h/2;
    for(let y=0;y<h;y++) for(let x=0;x<w;x++){
      const dx=x+0.5-rx, dy=y+0.5-ry; if((dx*dx+dy*dy) <= (Math.min(rx,ry)**2)) data[y][x]=true;
    }
  } else if(part.shape==='poly' && part.points){
    const pts=normalizePoly(part.points); // already sized by bbox downstream
    for(let y=0;y<h;y++) for(let x=0;x<w;x++){
      const px=(x+0.5)*cell, py=(y+0.5)*cell; if(pointInPoly(px,py,pts)) data[y][x]=true;
    }
  } else { for(let y=0;y<h;y++) for(let x=0;x<w;x++) data[y][x]=true; }
  return {w,h,data};
}
function normalizePoly(points){
  let minX=Infinity,minY=Infinity; for(const [x,y] of points){ if(x<minX)minX=x; if(y<minY)minY=y; }
  const nx=[]; for(const [x,y] of points){ nx.push([x-minX, y-minY]); } return nx;
}
function pointInPoly(x,y,poly){
  let c=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1];
    const intersect=((yi>y)!=(yj>y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 1e-9) + xi);
    if(intersect) c=!c;
  } return c;
}

function autoSheets(){
  const S=state.job.sheet; const instances=makeInstances(state.job.parts); sortInstances(instances, $('#sortBy').value);
  let res; const method=$('#strategy').value;
  if(method==='shelf') res=nestShelf(instances,S,S.kerf);
  else if(method==='bl') res=nestBottomLeft(instances,S,S.kerf);
  else res=nestTrueShape(instances,S);
  state.job.placements=res.placements; state.job.sheets=res.sheets;
}
function runNest(){ autoSheets(); draw(); }
$('#btnNest').addEventListener('click', runNest);
$('#btnClearPlacements').addEventListener('click', ()=>{ state.job.placements.length=0; draw(); });

/* ==============================
   Toolpath Preview & G-code
============================== */
function currentProfile(){ const id=$('#cncProfile').value; return state.profiles.find(p=>p.id===id) || state.profiles[0]; }
function applyKerfOffset(part){
  const k=state.job.sheet.kerf;
  if(part.shape==='circle'){ const r=Math.max(1,(part.w/2) - k/2); return {shape:'circle', w:r*2, h:r*2}; }
  const w=Math.max(1,part.w - k), h=Math.max(1, part.h - k); return {shape:'rect', w, h};
}
function previewToolpaths(){
  const S=state.job.sheet; draw(); ctx.save(); const margin=S.margin;
  ctx.strokeStyle='#71f1bd'; ctx.lineWidth=2;
  for(const pl of state.job.placements){
    const part=state.job.parts.find(p=>p.id===pl.partId); if(!part) continue;
    const off=applyKerfOffset(part);
    const x=pl.x+margin + (part.shape==='rect'?(S.kerf/2):0);
    const y=pl.y+margin + (part.shape==='rect'?(S.kerf/2):0);
    const sheetOffsetX=Math.floor(pl.sheet)*(S.w+80);
    const A=worldToScreen(sheetOffsetX+x, y), B=worldToScreen(sheetOffsetX+x+off.w, y+off.h);
    if(part.shape==='circle'){
      const c=worldToScreen(sheetOffsetX+x+off.w/2, y+off.h/2);
      const rx=(B.x-A.x)/2, ry=(B.y-A.y)/2; ctx.beginPath(); ctx.ellipse(c.x,c.y,Math.abs(rx),Math.abs(ry),0,0,Math.PI*2); ctx.stroke();
    }else{
      ctx.strokeRect(A.x,A.y,B.x-A.x,B.y-A.y);
    }
  }
  ctx.restore();
}
$('#btnPreviewToolpath').addEventListener('click', previewToolpaths);

function exportAllGcode(){
  if(!state.job.placements.length) runNest();
  const prof=currentProfile(); const S=state.job.sheet;
  const files=new Map();
  const header=(i)=>`(Job ${state.job.name})\n( Sheet ${i+1} )\nG21 ; mm\nG90 ; absolute\n`;
  const lead=parseFloat($('#leadLen').value)||0; const leadType=$('#leadType').value;
  const dwell=parseFloat($('#pierceDwell').value)||0; // comp currently not switching path side in this proto
  for(let s=0;s<state.job.sheets;s++){
    let g=header(s); g+=`F${prof.feed}\n`;
    for(const pl of state.job.placements.filter(p=>p.sheet===s)){
      const part=state.job.parts.find(pp=>pp.id===pl.partId); if(!part) continue;
      const off=applyKerfOffset(part);
      const x=S.margin+pl.x + (part.shape==='rect'?(S.kerf/2):0);
      const y=S.margin+pl.y + (part.shape==='rect'?(S.kerf/2):0);
      // move + lead
      let sx=x- (leadType==='line'?lead:0), sy=y; g+=`G0 X${sx.toFixed(3)} Y${sy.toFixed(3)}\n`;
      if(dwell>0) g+=`G4 P${dwell.toFixed(3)}\n`;
      if(lead>0 && leadType==='line'){ g+=`G1 X${x.toFixed(3)} Y${y.toFixed(3)}\n`; }
      if(part.shape==='circle'){
        const cx=(x+off.w/2), cy=(y+off.h/2); const r=(off.w/2); const n=64;
        let px=x+off.w, py=y+off.h/2; g+=`G1 X${px.toFixed(3)} Y${py.toFixed(3)}\n`;
        for(let i=1;i<=n;i++){ const a=(i/n)*Math.PI*2; const qx=cx + r*Math.cos(a), qy=cy + r*Math.sin(a); g+=`G1 X${qx.toFixed(3)} Y${qy.toFixed(3)}\n`; }
      } else {
        const p1=[x,y], p2=[x+off.w,y], p3=[x+off.w,y+off.h], p4=[x,y+off.h];
        g+=`G1 X${p2[0].toFixed(3)} Y${p2[1].toFixed(3)}\n`;
        g+=`G1 X${p3[0].toFixed(3)} Y${p3[1].toFixed(3)}\n`;
        g+=`G1 X${p4[0].toFixed(3)} Y${p4[1].toFixed(3)}\n`;
        g+=`G1 X${p1[0].toFixed(3)} Y${p1[1].toFixed(3)}\n`;
      }
      if(lead>0 && leadType==='line'){ const ex=x+off.w, ey=y; g+=`G1 X${(ex+lead).toFixed(3)} Y${ey.toFixed(3)}\n`; }
      g+=`(End part ${part.name})\n`;
    }
    g+=`M5\nM2\n`;
    files.set(`${state.job.name}_Sheet${s+1}.nc`, g);
  }
  for(const [name,content] of files){ download(name, content); }
}
$('#btnExportGCode').addEventListener('click', exportAllGcode);

/* ==============================
   CSV & SVG Export
============================== */
function exportCSV(){
  const lines=['sheet,part,name,x,y,w,h,rot'];
  for(const pl of state.job.placements){
    const part=state.job.parts.find(p=>p.id===pl.partId);
    lines.push([pl.sheet, part?.id||'', part?.name||'', pl.x, pl.y, pl.w, pl.h, pl.rot?1:0].join(','));
  }
  download(`${state.job.name}_placements.csv`, lines.join('\n'));
}
function exportSVG(){
  const S=state.job.sheet; const margin=S.margin; const sheets=state.job.sheets; const w=S.w, h=S.h;
  const svgParts=[];
  svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w*sheets}" height="${h}" viewBox="0 0 ${w*sheets} ${h}">`);
  for(let s=0;s<sheets;s++){
    const ox=s*w;
    svgParts.push(`<rect x="${ox+0.5}" y="0.5" width="${w-1}" height="${h-1}" fill="#0a1125" stroke="#33407a"/>`);
    for(const pl of state.job.placements.filter(p=>p.sheet===s)){
      const part=state.job.parts.find(pp=>pp.id===pl.partId); if(!part) continue;
      const x=ox+margin+pl.x, y=margin+pl.y, W=pl.w, H=pl.h;
      svgParts.push(`<rect x="${x}" y="${y}" width="${W}" height="${H}" fill="#14214a" stroke="#6ba2ff"/>`);
      svgParts.push(`<text x="${x+6}" y="${y+14}" font-size="12" fill="#bcd7ff">${part.name}</text>`);
    }
  }
  svgParts.push('</svg>');
  download(`${state.job.name}_layout.svg`, svgParts.join('\n'));
}
$('#btnExportCSV').addEventListener('click', exportCSV);
$('#btnExportSVG').addEventListener('click', exportSVG);

/* ==============================
   DXF (LWPOLYLINE only, beta)
============================== */
$('#dxfInput').addEventListener('change', async (e)=>{
  const file=e.target.files[0]; if(!file) return; const txt=await file.text();
  state.dxfGeom=parseDXF_LWPolyline(txt); toast(`DXF parsed: ${state.dxfGeom.length} polylines`); e.target.value='';
});
$('#btnAddDXFAsPart').addEventListener('click', ()=>{
  if(!state.dxfGeom || !state.dxfGeom.length){ alert('Load a DXF first.'); return; }
  const bb=boundOfPolylines(state.dxfGeom); const w=bb.maxX-bb.minX, h=bb.maxY-bb.minY;
  state.job.parts.push(new Part({name:'DXF '+(state.job.parts.length+1), w, h, qty:1, rot:true, shape:'poly', points:state.dxfGeom[0]}));
  renderParts();
});
function parseDXF_LWPolyline(txt){
  const lines=txt.split(/\r?\n/); const polys=[]; let i=0; let current=[]; let inLw=false; let closed=false;
  while(i<lines.length){
    const code=lines[i++].trim(); const val=lines[i++]?.trim(); if(val===undefined) break;
    if(code==='0' && val==='LWPOLYLINE'){ inLw=true; current=[]; closed=false; continue; }
    if(inLw){
      if(code==='0'){
        if(current.length){ if(closed && (current[0][0]!==current.at(-1)[0] || current[0][1]!==current.at(-1)[1])) current.push([...current[0]]); polys.push(current); }
        inLw=false; current=[]; closed=false; continue;
      }
      if(code==='70'){ closed = (parseInt(val)&1)===1; }
      if(code==='10'){
        const x=parseFloat(val);
        const ycode=lines[i++].trim(); const yval=parseFloat(lines[i++].trim());
        if(ycode!=='20') { i-=2; continue; }
        current.push([x,yval]);
      }
    }
  }
  return polys;
}
function boundOfPolylines(polys){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const poly of polys){ for(const [x,y] of poly){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; } }
  return {minX,minY,maxX,maxY};
}

/* ==============================
   Help
============================== */
$('#btnHelp').addEventListener('click',()=>{
  alert(`Mini Nest 2D — Quick Help

1) Create/Load a Job (top left).
2) Pick Material and set Sheet + Kerf.
3) Add parts (Rect/Circle), CSV, DXF, or folder import.
4) Run Nest (choose method).
5) Preview Toolpaths, then Export SVG/CSV/G-code.

Notes: True-shape and DXF arcs are beta. G-code is GRBL-style and generic.`);
});

/* ==============================
   Init
============================== */
function seedDemo(){
  if(state.job.parts.length) return;
  state.job.parts.push(new Part({name:'Bracket A', w:220, h:160, qty:6, rot:true}));
  state.job.parts.push(new Part({name:'Gusset', w:140, h:140, qty:10, rot:true}));
  state.job.parts.push(new Part({name:'Cover Plate', w:600, h:260, qty:4, rot:false}));
  state.job.parts.push(new Part({name:'Ring Ø200', w:200, h:200, qty:2, rot:true, shape:'circle'}));
}
function init(){
  refreshMaterialSelect();
  refreshProfileSelect();
  bindJobFields();
  seedDemo();
  renderParts();
  resizeCanvas();
  resetView();
  draw();
  toast('Mini Nest 2D ready.');
}
try { init(); } catch(e){ console.error('Immediate init failed', e); toast('Immediate init failed: '+e.message); }
</script>
</body>
</html>
